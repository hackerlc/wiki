##网络优化

###使用IP连接获取接口数据

如果使用域名来获取接口数据，那么首次解析DNS的时候会花费一些时间。

我现在的解决方式是先用域名请求一个接口，然后接口会返回后面app所需要的ip地址，这里也可以方便服务器做负载。然后把ip地址用shardPreference存起来方便下次使用，如果ip地址出现问题那么就再用域名请求。

当然这样还是会出现一些问题，第一次访问的时候始终还是访问了域名，对速度上有些影响。后面优化可以维护一张动态的请求列表，先用ip来请求，如果ip遇到问题那么再用列表里的其他地址请求，知道请求成功或全部失败，并且可以在app更新或其他时间更新此列表。

###服务器部署

这个可能就需要后台同学和运维同学的支持了，至少应该同时支持三大运营商，然后根据地域和网络类型选择最优的网络连接。

###HTTP

HTTPClient 方式

```
    private static final int DEFAULT_MAX_CONNECTIONS = 30;
    private static final int DEFAULT_HOST_CONNECTIONS = 10;
    private static final int DEFAULT_TIMEOUT = 1000;
    private static final int DEFAULT_SOCKET_TIMEOUT = 20 * 1000;
    private static final int DEFAULT_SOCKET_BUFFER_SIZE = 8192;
    /**
     * 获取一个HttpClient对象
     * @return
     */
    public static synchronized HttpClient getHttpClient(){
        if(httpClient==null){
            final HttpParams httpParams =new BasicHttpParams();

            //设置获取连接池超时
            ConnManagerParams.setTimeout(httpParams, DEFAULT_TIMEOUT);
            //设置访问服务器超时
            HttpConnectionParams.setConnectionTimeout(httpParams, DEFAULT_SOCKET_TIMEOUT);
            //设置服务器返回信息超时
            HttpConnectionParams.setSoTimeout(httpParams, DEFAULT_SOCKET_TIMEOUT);

            //设置路由最大连接数
            ConnManagerParams.setMaxConnectionsPerRoute(httpParams, new ConnPerRouteBean(DEFAULT_HOST_CONNECTIONS));
            //设置最大连接数
            ConnManagerParams.setMaxTotalConnections(httpParams, DEFAULT_MAX_CONNECTIONS);

            //设置先发送请求头，如果通过再继续
            HttpProtocolParams.setUseExpectContinue(httpParams, true);
            //设置是否使用重用连接，如果不使用可能会出现IO异常，默认使用但会花费时间10-30ms
            HttpConnectionParams.setStaleCheckingEnabled(httpParams, true);

            // set user agent
//            String userAgent = "Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.2) Gecko/20100115 Firefox/3.6";
//            HttpProtocolParams.setUserAgent(httpParams, userAgent);

            // 设置不使用Nagle算法，增加效率和带宽消耗
            HttpConnectionParams.setTcpNoDelay(httpParams, true);
            HttpConnectionParams.setSocketBufferSize(httpParams, DEFAULT_SOCKET_BUFFER_SIZE);

            // scheme: http and https
            SchemeRegistry schemeRegistry = new SchemeRegistry();
            schemeRegistry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80));
            schemeRegistry.register(new Scheme("https", SSLSocketFactory.getSocketFactory(), 443));

            ClientConnectionManager manager = new ThreadSafeClientConnManager(httpParams, schemeRegistry);

            httpClient=new DefaultHttpClient(manager,httpParams);
        }
        return httpClient;
    }
```
